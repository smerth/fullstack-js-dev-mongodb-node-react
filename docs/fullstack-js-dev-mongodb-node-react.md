Stopped at 3.2



[Course link](https://www.lynda.com/Express-js-tutorials/React-components/533304/557613-4.html)





# Introduction

## Course overview



## What this course covers

Quick overview of the course. I'll start with an intro into the modern JavaScript features which I'm going to be using throughout this course, and also the options to set up and configure a full stack application. 

We'll then see how we can use Node as our web server. After that we'll cover the React basics and see how to work with data, first in memory, then with an API. We'll adopt the server-render first strategy and make sure our applications are isomorphic, which means it will render initial HTML for all supported routes. 

This will help us be a little bit more efficient and it helps with SEO, search engine optimization, which is extremely important. Routes will work on both the client-side and the server-side, and we'll then take our API into MongoDB and see how to integrate it with the application. We will be reading and writing to MongoDB. 

When it comes to the front end, this course has pure focus on React itself, which means we're not going to cover other libraries that's designed for React, like Redux or even React Router. 

We're completely focusing on pure React here. My hope is that once you truly understand the dynamics of working with the React API, then understanding and using these other libraries will be a lot easier. I'll be explaining what I do as I type, and as I'm not a perfect human, I'll probably run into many problems, and we'll see how to debug and solve them together. 

I'll try to be not too slow and not too fast, but remember that you can always control the play speed. We will be doing a lot of things in this course. Some will be easy and others will be hard. Remember that you can pause, skip, and replay when needed, but you can also directly ask me questions. If you have any questions while you're taking this course, you can find me on the Slack jsComplete questions channel. 

You can get an invite for that on this website, and I also answer questions on Quora and Stack Overflow, especially if you ping me for an answer. Asking follow-up questions is perhaps the most effective way of learning, and I'm happy to answer. 

# 1. Getting Started

## Modern JavaScript

The current Node version supports a lot of the modern Javascript features finalized by ECMAScript. I will be using most of these features like destructuring and error functions, among many others. In this movie, I'll review the features I'll be using in this course. If you're comfortable with ES2015 and beyond, feel free to skip this movie and jump on to the next chapter. 

First, let's talk about scopes. Quick trick question, is this a valid Javascript line of code? Yes, it is, because these are nested block scope. I can define a variable here, and then access it after. In Javascript, we have a function scope, and we have a block scope. The good old function scope gets created every time we define a new function. Block scopes can be simple begin-end curly braces like this, or when used in an if statement, or a for statement. The var keyword behaves differently in a function scope and a block scope. A variable defined with var in a function scope can't be accessed outside the scope, while a variable defined with var in a block scope is available outside of that block scope. For example, the i variable that we use in a for loop will continue to exist beyond the scope of the loop, which does not make sense, really. This is why, in modern Javascript, we have a new keyword to define variables, let. Variables defined with let inside any scope are only accessible inside that scope, making let the ideal solution for the for loop index variable problem. If we use let to initialize the i variable in a for loop, the variable will only be defined inside the for loop. Const is exactly like let, but defines a constant reference for a variable. We can't change the value of a constant reference. If we put a primitive value in a constant, then the value will be protected from getting changed. Note that if the constant is an object, like this one, we can still change the properties of the object, but we can't change the object itself. If we want a completely immutable object, then we'll have to use something else, like object.freeze or Immutable JS. Constants are popularly used when importing things from other libraries so that they don't get changed accidentally. They're also used to define functions because we rarely need to update a function after we define it the first time. Speaking of functions, I think someone on the TC39 committee hates the word function, because with the latest ECMAScript features, we can completely avoid typing it. Instead, we can use the new arrow functions and text. The arrow comes after the arguments. The arrow functions and text is even more concise when the function takes one argument that has one line to return something. We can omit the parentheses, the curly braces, and even the return keyword, and the function will be the same. These one-liner functions are usually used for callbacks in simple map reduced filter operations and functional programming in general. Also, when defining a function as a property on an object, we can use this new shorthand notation, which I really like, even more than the arrow functions. Arrow functions, beside being shorter and more fun to type, are lexically scoped, which is a fancy way of saying that they close over the this keyword available on their parent, while regular functions use the caller to determine what's inside their this keyword. For example, in a Node module, the top level, this keyword, is the exports object, which is empty by default. I'm adding a property i here just to identify it. In here, I have a util object, which defines two functions. F1 is regular scope, f2 is arrow scope. When we normally call f1, the this keyword in f1 will be the caller, which is the util object, while the this keyword in f2 will be the parent scope, which is the exports object. This is a huge benefit when working with closures and we will be taking advantage of that. When we define an object like X here and we have other objects, functions, or modules that we want to export as properties on the X object, we can omit the values when the property name and the values are the same just like this, which is equivalent to the commented version here. When we want to read properties from X and assign them as variables with the same name, we can use the destructure syntax instead of typing the name twice, like this. This is much more impressive when we need to destructure multiple properties from the same object. Without destructure, this line would need to be three lines. You'll see me using this pattern to import objects and functions from libraries when I use Node's require function. For example, the React library has a component property. So instead of doing const Component = require('react').component, we can destructure the component out of the required line like this. Destructuring works inside function arguments, too. If the argument is an object, instead of having one variable to represent the object, we can destructure the properties that we want from that object into variables available in the function body. Function arguments, including destructured one, also get default values if we don't specify a value for them when we call the function, like this. We can still specify a default value here. We can also use rest parameters to capture the remaining arguments into an array like numbers here, which has the three binary numbers left after naming the first base argument. Numbers will be an array thanks to rest parameters. We can also use a three dots operator to pass array elements as positional arguments. For example, to clone an array and add elements to it. This is very helpful when we work with immutable objects and it's also widely popular with React components properties. In this last pattern, we call these three dots the spread operator. They can be used to spread values of one array into another array, or key value pairs of an object into another object. Modern Javascript also has a new import export syntax to replace the require syntax that we saw before. This is not yet supported in Node itself, but we can easily get it compiled into what Node understands using a tool like Babel. Finally, while I'm not really a big fan of classes, we're going to use a class syntax to define React components. A class is a wrapper around the constructor function, and we can extend other classes and customize the constructor function when we need to. We'll use this syntax to define stateful React components. There is a lot more features than what I quickly explained here, but those are the ones that we will be mostly using in this course. Alright, time to roll up our sleeves, stop staring at the blank page, and implement our first increment toward a full stack Javascript application with Node and React. "

## Setup and configurations

"- [Teacher] Let's set up our development environment first.<br>We're going to have a Node web server, and we<br>want to write react components for the front end,<br>and we want our Node web server to render initial<br>static HTML from our front-end React components.<br>We also want a Node API server to talk to the database.<br>To keep things simple, I'll create one<br>Node project to perform all three tasks.<br>We don't want to optimize things very early on.<br>I'll be tracking the progress of the project<br>we're going to build in this course using GitHub.<br>This is the repository that I'll be using,<br>under jscomplete/learn-fullstack-javascript.<br>Every video in this course will<br>have a Git tag associated with it.<br>You should clone this repo and try things out with me,<br>and at the end of each video, you can compare your<br>code with the code at the Git tag for that video.<br>This repo will also have a script to load some test<br>data for us to start working with, and also all the<br>CSS that I'll be using in this course so that you get<br>the same look and feel of what we see here in the course.<br>If you're comfortable setting up a full stack JavaScript<br>development environment, you can actually skip this<br>video and check out Git tag v1.2 to fast-forward to<br>the point we're going to start with in the next chapter.<br>However, I recommend going through this setup video, as I'll<br>be explaining key things about the structure of the project.<br>I've already cloned the course repo into<br>my machine under this fulljs directory.<br>To start any Node project, your first step is to<br>create a package.json file to store general information<br>about the project and track its dependencies.<br>You can generate a package.json file with<br>this npm init command and either keep<br>the default answers or type new answers.<br>We have a package.json file, which means that we can<br>start documenting and installing our dependencies.<br>I'll install them one by one here so<br>that we talk about them as they install.<br>We're going to have two types of packages.<br>The main dependencies are the packages our code will<br>use in production, and we'll have dev dependencies<br>that are only used in a local development environment.<br>Let's start with the main dependencies.<br>To create a node web server, we're going to use Express.js.<br>So that would be our first dependency here.<br>npm install --save express.<br>The --save will write this dependency to package.json.<br>Our database of choice for this course is MongoDB.<br>To connect to Mongo from Node, we need a driver,<br>and we'll be using the official driver here,<br>which we can install as npm install mongodb.<br>Note how I used shortcuts for install and --save<br>because, well, I'm a lazy typer.<br>Express and Mongo cover the main<br>backend dependencies that we need.<br>Our frontend is going to be purely React and nothing else.<br>So let's bring in React here<br>with npm install react and react-dom.<br>We use the React library to describe our user interfaces<br>and the ReactDOM library to render those user interfaces<br>on both the frontend and the backend.<br>We're going to introduce more dependencies later,<br>but for now, this is a good start.<br>Let's now install our dev depencies,<br>the first of which would be webpack.<br>Since we're going to be writing modular code everywhere,<br>we need a tool to translate modular code<br>into something that browsers understand today.<br>webpack is the most popular tool for that job.<br>As a webpack loader, we're going to use Babel to transform<br>the JSX extension code into what React understands.<br>We'll also use Babel to transform a few<br>of the modern JS features that are not<br>yet supported natively in all browsers.<br>Here are the packages we need to make all that happen.<br>babel-cli, babel-loader, babel-preset-es2015,<br>babel-preset-stage-2, and babel-preset-react.<br>I'll explain how to use these presets in a little bit.<br>When we change things in a Node.js project,<br>a restart is required for the changes<br>to be reflected in the running process.<br>But instead of manually restarting Node, let's bring<br>in the nodemon package, which can monitor our files and<br>auto-restart Node for us when we save changes to disk.<br>Finally, I'm a big fan of ESLint,<br>and I do not work in any project unless I have<br>the eyes of ESLint to watch over my shoulders.<br>I can't say enough about how important this is,<br>but I hope you trust me on this one and<br>npm install eslint, eslint-plugin-react, and babel-eslint.<br>I won't go through configuring ESLint itself<br>because it's beyond the scope of this course,<br>but I'll add a ready-to-use with this project<br>ESLint configuration file to the GitHub repo,<br>and you can get it from there.<br>You can see the exact versions I'm using<br>in this course here in package.json.<br>You'll probably see different versions when you<br>install them yourself, but as long as you use a<br>version that's on the same major version level here,<br>which is the first number, you should be okay matching<br>the experience I'll be going through here in this course.<br>You can always install specific NPM<br>package versions using an @ after the name.<br>For example, to install this same Express version I'm using,<br>you can do npm install express@4.14.0.<br>And of course, if you just copy my package.json file,<br>you can install the exact same<br>versions with an npm install command.<br>I'm going to create an initial directory<br>structure for this project now.<br>First, let's have all of our JavaScript frontend<br>modular code under a source directory.<br>It's a popular convention to name this<br>directory source because it will be the<br>source of our generated working files.<br>Another popular convention is to have a public directory<br>to host our static assets like HTML, JavaScript, and<br>CSS files, that will actually be loading on clients.<br>We're going to have Express serve these public<br>files directly with its static middleware.<br>Finally, let's create a directory<br>for our backend API server.<br>I'll add empty files to these directories<br>so that I can commit them to the GitHub repo.<br>An index.js file in the API directory,<br>an index.html file in public,<br>and an index.js file in source.<br>The index name is usually used to reference<br>the starting point in every directory.<br>Let's now prepare some NPM scripts.<br>We will not be doing any automated testing in this course,<br>although that's probably a very bad decision, but I trust<br>that you know the value of writing tests for your code.<br>Testing is a big subject by itself, and I'll probably have<br>a course dedicated to testing Node and React applications.<br>Maybe after this one.<br>The first script we need is to run the Node server,<br>which I'll put in as server.js file.<br>So our start script would be to node server.js,<br>but since we want our code to work with babel and nodemon,<br>we want to add a nodemon execution wrapper<br>and use babel-node instead of node.<br>I'll also ignore the public directory from nodemon.<br>Watch as changes there are usually<br>driven by changes in the source directory.<br>To transform the source files into a bundled<br>file for the browser, let's have the dev script<br>that fires the webpack command using the -wd flags<br>to also run in watch node and development mode.<br>We'll need to configure webpack to work with our<br>structure, which is a long story, but I'll copy<br>the configurations here and we'll talk about them.<br>In this webpack.config.js file on the root level, we tell<br>webpack to start from the index file under the source<br>directory, and bundle all the modules we depend on inside<br>that file into a bundle.js file under our public directory.<br>Then for every file that ends with a .js,<br>we want to run the babel-loader on it.<br>The babel-loader will take care of transforming the<br>non-standard JS that we'll be using, like JSX and ES2015<br>modules, which are not yet supported natively in browsers.<br>To configure Babel to work with our selected presets,<br>we can add the .babelrc file on the root level<br>and add the following code.<br>This instructs Babel to use these three presets:<br>react is used to transform JSX, and the other two presets<br>for us to safely use JavaScript modern features<br>and not worry about browsers that do not understand them.<br>I picked stage-2 here because I think any proposal that<br>makes it to the draft stage has a very high chance of<br>getting finalized as is or with very small modifications.<br>Finally, here's the promised ESLint configuration file,<br>which you can find on the root level in the Git repo.<br>With all these configurations out of the way,<br>let me commit all the changes here and tag this<br>point of the course as v1.2 to match the video number.<br>"



# 2. Node as a Web Server

## Node modules

"- [Instructor] To work in a Node project,<br>we first have to understand how the module system work.<br>We bring in a module dependency using an import line.<br>For example, say that we have a config module somewhere.<br>We require it with the import config line.<br>This syntax, however, looks for config<br>as either a core module or an npm installed module<br>in node modules.<br>If we want to place our config.js file somewhere else,<br>we can use a relative path in the string, here.<br>For example, ./config tells Node<br>to look for config.js on the same level<br>as the current file.<br>We can also use ../ to go up one level if we want to.<br>Let's create a config.js file<br>here on the same level as server.js.<br>And put a simple console.log line in here.<br>Since we're using the new import syntax,<br>we need to use babel-node here to test the server,<br>but we only installed babel-node locally, not globally.<br>It's available under ./node_modules/.bin/babel-node,<br>and we can invoke it from there directly.<br>However, instead of using the .bin path like this,<br>we can actually make ./node_modules/.bin/<br>part of the global path variable.<br>All we need is to edit the bash_profile file.<br>This is on Mac, though,<br>so on Windows things will be different.<br>And we want a export path to be the current path<br>adding ./node_modules/.bin<br>just like that.<br>This is a relative path,<br>so when we go to any node project<br>the ./node_modules/.bin folder<br>will be included in the global path,<br>which is really handy.<br>To reload this file, close and open the terminal.<br>And now babel-node should be available directly here<br>thanks to the relative path we just added.<br>No need to install a global binary.<br>All import calls are cached.<br>This means if we re-import the config,<br>we're not really evaluating the config file content again.<br>It will just be read from the cache.<br>This is why it's okay to import the same file<br>multiple times from multiple other files,<br>because the cache will be used after the first import.<br>It's important to understand that<br>every module gets its own private scope.<br>So, defining a top-level variable here,<br>for example, env = process.env.<br>This does not mean that we're putting the variable<br>env on the global scope, unlike a browser environment.<br>So, if I try to console.log(env) in server.js,<br>this will not work, because env is undefined on server.js.<br>It's defined in config.js.<br>So, with node modules<br>we don't have to wrap things<br>in an IIFE to get a new scope.<br>Node actually does the wrapping for us automatically,<br>which is neat.<br>Let's clean that up.<br>I'm actually going to remove the console.log line,<br>and let's actually make this into a constant,<br>because I'm not going to be changing it.<br>Usually when we import something<br>we import it into a variable, just like this.<br>And let me go ahead and console.log(config).<br>So, right now this config is actually an empty object,<br>because we have not exported anything in config.js.<br>So, let's go ahead and export something.<br>When we import with this syntax,<br>we're importing the default exported object<br>in the config module.<br>For example, let's export default object<br>with a port property,<br>and let's make this property reads from env.PORT<br>and default to 8080.<br>This way we can control the port from the process,<br>but we don't have to.<br>Now, our import from line places the default export<br>into the config variable<br>so we can read the port property<br>from the server.js file.<br>We can also export other things<br>beside the default object.<br>For example, let's export a constant, nodeEnv.<br>Set that to env.NODE_ENV<br>and default to development.<br>To import a non-default export,<br>we need the destructure syntax, nodeEnv.<br>And let's go ahead and console.log that as well.<br>And there you go.<br>We can also export functions like this logStar, here.<br>When we import the function,<br>we also need to destructure this,<br>because it's not a default export.<br>We can simply invoke the logStar variable,<br>because it holds a function reference.<br>"

## The HTTP/HTTPS modules

"- [Instructor] I find it useful to understand<br>Notes http module itself before using Express.<br>Express is really a wrapper around the Node<br>core http module.<br>The http modules in Node can actually be used<br>as both client and a server.<br>We bring them in by importing http or https.<br>These are core modules so we do not need<br>to mpm install them.<br>Let me first show you how we can<br>use these modules as clients.<br>We can use the request method or if we're<br>just doing a get request we can use the get method.<br>For example let's read the content of linda.com.<br>We do https.getlinda.com.<br>We're using https here because the url is https.<br>If the url was http you would use the http module instead<br>and the call back for this get<br>method receives a response stream.<br>We can read methods like statusCode on this stream<br>and we can listen for data events on that stream.<br>Every event will give us a chunk buffer<br>so we can read its content with a twoString call.<br>To test this we can babel-node the file<br>and let's pipe the output unless to paginate it<br>because it's going to be big.<br>We get a 200 okay and the html of linda's home page.<br>Now let's see how to use the http module as a server.<br>After we import it we use the create server call<br>to create a server, no surprise there,<br>and then use the listen method to run the server<br>on a certain port.<br>Create server gives us an event<br>emitted object which we can subscribe to.<br>The most important emitted event is the request event<br>which gets emitted every time<br>the http server receives a request.<br>The call back for this event receives two special objects.<br>A request object and a response object.<br>The user initiating the request will see<br>anything we write to the response object.<br>While we can use the request object<br>to read things from the request.<br>For example, what url was requested?<br>Were there any query string parameters<br>with the request and many other things.<br>Let's write a simple hello http string<br>back to the requester.<br>The response object is a writable stream,<br>which means we can use it to stream<br>data to the user and that's extremely powerful.<br>Let's write another line to the user<br>after three seconds using a timer like this<br>and after that let's go ahead and terminate<br>the stream response with the .end call.<br>Run the server with babel -node server.<br>When we initiate a request for the server<br>we'll first get the hello HTTP line<br>and after three seconds we'll get the<br>I can stream line, then the response gets terminated.<br>We can supply the request event listener callback<br>as the argument for create server itself.<br>And Node will automatically attach<br>the argument to the request event.<br>As you can see the core http module<br>is extremely powerful on its own<br>and it's very simple to set up a server with it.<br>However, as the requirement for handling a request grows,<br>using the core module on its own would be hard<br>as there will be a lot of boiler plate code<br>that can be extracted into a framework type library.<br>This is why we have Express JS and many other<br>similar options but Express is the most popular one.<br>So in the next movie we'll go ahead<br>and learn the basics of Express JS.<br>"

## Creating an Express server

"- [Instructor] Let's do the equivalent of what we did<br>with the HTTP module, but with Express instead.<br>We first need to import Express,<br>and to create a server with Express,<br>we just invoke the imported Express variable as a function.<br>If you read the source code of the Express package,<br>you'll find out that the default export there<br>is just a function,<br>similar to the HTTP module.<br>We also do a .listen method on the Express server.<br>I'll read the port from the configuration file this time.<br>We just import config<br>and use config.port in the listen call.<br>The second argument to the Express listen<br>is the success handler, which is just a function.<br>So let's output a line that the Express server<br>is listening on the configured port.<br>Instead of listening to a single request event,<br>an Express server also handles server side routing for us.<br>So it exposes an API to listen to certain routes.<br>We do a server.get,<br>specify the route we're interested in<br>as the first argument,<br>which is the route / in this case,<br>and the second argument to this .get call<br>is the event handler,<br>which similar to the HTTP module,<br>receives both a request and a response object.<br>In Express, we can use other methods<br>to send things to the requestor.<br>For example, to send a simple string,<br>we can use response.send here.<br>Let's test,<br>curl http 8080<br>and we get Hello Express.<br>Let's add another route.<br>Similar syntax,<br>this time /about.html,<br>and here we're going to send<br>The about page.<br>Let's go ahead and test that,<br>curl /about.html<br>and we get The about page.<br>Let's also make sure that we can access this on the web.<br>So Hello Express,<br>/about.html,<br>and about.html is The about page.<br>A web server however does not return<br>simple strings like these,<br>it returns the content of a file,<br>like HTML or JS.<br>So let's create a very simple about.html file in here,<br>and I'm going to copy here a simple HTML template for it,<br>and we want this template to be our reply<br>to our requestor for the /about.html route.<br>We can simply use the fs core module.<br>I'm going to go ahead and import fs from fs,<br>and inside about.html,<br>the API is readFile,<br>the path to the file,<br>then the callback is going to give us access<br>to the file's data as a buffer,<br>so we can send as a response data.toString.<br>And we can test this by refreshing the about page,<br>we get the HTML file.<br>It's really that simple,<br>but it can actually be simpler.<br>Express has a static middleware<br>that we can use to automatically serve static assets<br>like this about.html file.<br>All we need to do is this magic line,<br>.use is how we put a middleware<br>in the Express middleware stack,<br>and public is where we want our static assets<br>to be hosted on the file system.<br>With this line, we don't need to handle<br>the route for /about.html,<br>or even use the fs module.<br>We just need to move about.html<br>to under public,<br>and Express will take care of serving its content<br>to a requestor.<br>Restart the server,<br>and make sure the about.html is still working.<br>In a production environment,<br>we should manage static assets separately<br>from the node server,<br>as there are much faster options like NGINX.<br>To keep things simple in development though,<br>I'm just going to use the simple Express static middleware.<br>With Express, we can also manage a group of routes<br>in their own module,<br>instead of having everything here in server.js.<br>For example, we're going to manage all API requests<br>in this API module index.js.<br>So we import Express here,<br>then we create a route object<br>by calling the router from channel in Express.<br>If you're now wondering how come<br>we can invoke Express itself,<br>and we can also invoke properties on Express,<br>remember that a function in JavaScript is just an object,<br>so we can attach other properties on that object.<br>This router object is similar<br>to the server object we used before,<br>we can define .get calls on it<br>and handle them in the second argument.<br>This is an API call,<br>so I'll send a JSON response<br>by sending an object here.<br>Finally, to be able to use this router,<br>we need to export it.<br>In the main server.js,<br>we first import this API router,<br>and we can use it just like any other Express middleware.<br>First argument is the route prefix,<br>and the API router is the second argument.<br>To test this, go to /api,<br>and we should see the empty data object<br>we send in the API module.<br>"

## Using the EJS template language

"- [Instructor] We usually need the server to respond<br>with an HTML view template, but with dynamic content inside.<br>Instead of generating a big HTML string<br>and responding with that,<br>we can use a dynamic template language like EJS,<br>short for embedded JavaScript.<br>There are many options for a template language,<br>but EJS is the simplest of them all.<br>We will be using the EJS template language engine<br>to server-render our JavaScript front end components.<br>Setting up EJS to work with Express is very simple.<br>This is the magic line that we need,<br>which sets the view engine to be EJS.<br>Express takes care of all the details after that.<br>By default, this can be configured.<br>Express will look for the EJS templates<br>under a Views folder on the root level.<br>Let's create an index.ejs file under that Views folder.<br>And inside with index, I will put a standard HTML template.<br>The EJS files are regular HTML files,<br>but we can embed JavaScript in them<br>using these template tags,<br>for example, let's output a math random number.<br>To render an EJS template, for example, on the root level,<br>we can use the response dot render method,<br>passing in the name of the template,<br>without the extension, which is the default.<br>Of course, EJS is a dependency,<br>so we need to bring that in with npm.<br>Once we have that, start the server one more time,<br>and let's test.<br>We'll see our index.ejs file rendered with a random number,<br>and every time we refresh, we get a new random number.<br>We can also pass variables from Express<br>into EJS using the second argument of render.<br>For example, let's pass in a content string here,<br>and let's try to use it.<br>In the EJS template, this content variable will be available<br>as a regular JavaScript variable,<br>so we can use it here directly.<br>And when we test,<br>we'll see the string coming from Express rendered with EJS.<br>If the content string had HTML markup in it,<br>for example, if EJS was wrapped in an EM tag,<br>then by default, the EJS template tag equal<br>will escape the content.<br>To output the variable unescaped into the template,<br>we can use a dash template tag instead.<br>Testing for that, the HTML is rendered.<br>Another useful feature in EJS<br>is that it supports partial views.<br>For example, this header portion of the HTML<br>is likely to be rendered exactly the same<br>in multiple EJS templates.<br>We can take it to its own partial EJS file.<br>Let's call this file header.ejs, paste it in here,<br>let me change the title,<br>make sure that we're rendering this new one<br>instead of what we had before,<br>and then in index.ejs,<br>I'm going to replace this header with an include call,<br>include header.<br>And let's go ahead and test that.<br>So you can see the new header was rendered.<br>We can do the same thing for footer.<br>Go ahead and create footer.ejs,<br>and let's take this part, put it in footer,<br>and similar to include header,<br>we're going to go ahead and include footer.<br>Make sure all is good, and we're all set to using EJS.<br>There are some great alternatives<br>to the packages we used so far.<br>For example, instead of ExpressJS,<br>we could use the new Koa framework,<br>which uses middleware generator functions<br>and provides a higher level syntax sugar<br>on top of the low level middleware layer.<br>There's also Hapi.js, which claims to be more focused<br>on delivering the business value.<br>There's also Sails.js, which is inspired<br>by the MVC pattern in Ruby on Rails.<br>For templating engines, the most popular one<br>is actually Pug, which used to be Jade.<br>Pug uses a white space-sensitive syntax<br>with indentation replacing the need for begin end tags.<br>Another popular template language is Handlebars,<br>which focuses on semantic templates.<br>I actually like Handlebars the most.<br>It's my go-to template language,<br>but EJS was a much simpler choice for this course.<br>There are many other options for both the web framework<br>and the template engine.<br>No matter what options you end up picking for a project,<br>just make sure they are properly maintained on GitHub<br>and responsive to any issues filed by the community.<br>While the syntax will be different,<br>the concepts are mostly the same.<br>Back in our project,<br>I added Bootstrap CSS framework here in our header,<br>and added the container class to the body element,<br>did a little bit of cleanup,<br>and I think we're ready to start doing things<br>on the front end now.<br>"

# 3. React Basics



## React elements and JSX

"- [Instructor] Let's render some HTML with pure JavaScript.<br>React takes the approach of generating HTML with JavaScript.<br>It does that for many reasons.<br>The most important ones are that we get the full power<br>of JavaScript to work with our data,<br>and before we generate the HTML,<br>we can represent it as a JavaScript object tree,<br>which allows React to compare it<br>against future versions of the same tree,<br>and generate partial HTML nodes to take to the browser.<br>This concept is known in React as the virtual DOM.<br>We will write our React application<br>under the source directory, here.<br>In index.js, to start working with React,<br>we need to import React first.<br>We import React from React, we also need to import ReactDOM,<br>since we're going to be working with a browser.<br>We import it from ReactDOM.<br>The first ReactDOM API that we need is to render something.<br>So the function is render,<br>and this function takes two arguments.<br>The first argument is what to render.<br>We're going to render a React element.<br>So the API is React.createElement,<br>and we'll come back to its arguments in a little bit.<br>The second argument to render<br>is where we want this element to be rendered.<br>So we're going to render it simply<br>in an element in the document.<br>I'm going to use get element by ID, which is a DOM API,<br>and give it root, so in here, I'm saying,<br>render it to an element<br>in the document that has the ID root.<br>So we don't actually have an element<br>in the document that has an ID root,<br>so I'm going to go under views, index.js,<br>I'm going to introduce a new element that has the ID root.<br>And let's go ahead and also<br>put this content inside the root.<br>Just like that.<br>So this means, if we initially have content,<br>go ahead and render it,<br>but after the JavaScript environment loads up,<br>React is going to take over this root div,<br>and it will replace the content<br>of the root div with the React application.<br>This will help us when we want to do server-side rendering.<br>So let's go back to the arguments<br>of the create element API method.<br>The first argument to create element is the HTML tag type,<br>so let's render an h2.<br>The second argument is any attributes<br>that we want this h2 to have.<br>If we don't have any attributes,<br>we can just pass a null here.<br>And the rest of arguments for the create element call<br>are all the children that we want this element to have.<br>So let's render a simple Hello React.<br>Looks good, now to get this working,<br>we need to run npm run dev,<br>this will run our webpack and generate the bundle.js file<br>from our React source code so far, as you can see,<br>there's a bundle.js file now generated.<br>This bundle.js is generated under public,<br>so just like we served about that HTML statically<br>with the Express static middleware,<br>we can also serve bundle.js statically.<br>But we do need to include this bundle.js<br>in our HTML somewhere.<br>Usually, we include it in the footer,<br>right after everything else,<br>so in here we can go with a script tag<br>and just do /bundle.js here.<br>We'll also need to run our node webserver,<br>which we can do with npm start.<br>Looking good!<br>Let's go ahead and test.<br>Local host, port 880, and we get Hello React.<br>So as you noticed, in source index.js,<br>we actually wrote pure JavaScript.<br>There's no HTML in here,<br>and the result was an HTML h2 element.<br>The return value here in React.createElement,<br>we can actually test it.<br>If you go to reactjs.com, the official React site,<br>and open up a console,<br>React is globally available here, so we can test it.<br>So React.createElement h2<br>is going to give us a simple object.<br>This object has many properties,<br>but the most important properties<br>are the type of the object, which is an h2,<br>and the props property, which has a children property<br>that holds the text that we just rendered.<br>So with React, we simply describe HTML elements as objects,<br>and then React put them together into a tree.<br>And it keeps a copy of this tree in memory,<br>so when things change, React will recalculate the tree,<br>and actually compare trees.<br>And it takes to the browser only the difference<br>between the new tree and the old tree.<br>And this makes React very efficient.<br>However, working with React API like this<br>is not very pleasant, because we're very used to HTML.<br>This is why we can use JSX.<br>So with JSX, we get to actually write HTML in here,<br>just like that, same thing, Hello React with JSX.<br>This will just work because we configured Babble<br>to actually compile this code into React.<br>So we can test, and it's working,<br>and with this approach, we get to write the familiar HTML,<br>but we also get the benefits of the React Virtual DOM.<br>With JSX, also, we get to use JavaScript variables.<br>So, I can do Math.random here, just like that,<br>and every time I refresh,<br>I'm going to get a different random value.<br>So inside those curly braces,<br>I can put any JavaScript expression,<br>and this way we have the full power of JavaScript itself<br>to generate the HTML.<br>Let me actually show you an example of that.<br>I'm going to put these on multiple lines,<br>and I'm going to go ahead and create a variable, color.<br>And this is going to depend on the Math.random value.<br>So I'm going to take the Math.random value,<br>and I'm going to do a condition here.<br>If Math.random is greater than .5,<br>I want the color to be green.<br>Otherwise, I want it to be red.<br>So this is a simple ternary statement,<br>and I'm going to go ahead and use it.<br>In h2 here, I can pass a style object,<br>and this style object could be a variable.<br>And we pass an object here inside that variable.<br>So we can do any CSS style in here.<br>So I'm going to go ahead and do color is color.<br>And with this, the color for the h2 element<br>is going to be randomly selected,<br>sometimes it's going to be green, sometimes going to be red.<br>Let's go ahead and test.<br>Green.<br>Green.<br>Red.<br>And by the way, we can limit this part, because it matches,<br>so we can just do color in here.<br>So you see how we have the full power of JavaScript<br>to control the HTML that we write to the browser.<br>Let's clean up this example.<br>So, JSX is really similar to HTML.<br>There are a few very subtle differences.<br>For example, if you want to pass a class to this element,<br>you can't just do class.<br>You have to do class name.<br>So for example, text center here, that's the class name,<br>to center a text in Bootstrap,<br>and lets make sure that this is working.<br>Let me remove the Math.random part.<br>So we go with class name<br>because the DOM API is actually class name.<br>So for example, if you do document.getElementById<br>for our root element,<br>this is a non-element,<br>let's go ahead and put it in a variable, DE.<br>So now if we want to do stuff on DE,<br>for example, if I want to change the class name of DE,<br>this is the DOM API.<br>It can do class name, there's class list,<br>there are plenty of other APIs that you want to explore.<br>So React actually used the same thing as the DOM API,<br>so it's class name and not class.<br>"

## React components

"- [Instructor] Lets' talk about React Components.<br>We don't usually work with React elements directly<br>like that, instead we use components.<br>For example, the top level component is usually<br>an App component, and we define the component as a constant.<br>A React component is simply a function, and in that function<br>we return the html that we care about.<br>Just like that.<br>Go ahead and change this to make sure it's working,<br>and refresh, there you go.<br>So, you'll notice that I am using the component just as if<br>it was a regular html element.<br>We can actually think of html elements<br>as built-in components, and React components is here to<br>extend our capabilities of html elements.<br>React components are super useful, they first allow us to<br>write code that's more readable.<br>We can also reuse React components.<br>For example, let's make this component reusable.<br>So, let's pass a variable to this component,<br>I'm going to call this variable headermessage,<br>and this is just a string.<br>In React components we call these variables props,<br>and the React component actually receives these props<br>in here as an argument to the function,<br>and inside the component dom, we can use these props.<br>So let's do props.headerMessage in here,<br>and you'll notice ESLint is giving us an error,<br>I'll get back to this error in a little bit,<br>but we can go ahead and test this, so whatever we pass here,<br>we can reuse in the component.<br>This makes this component reusable with<br>multiple header messages.<br>That's one other benefit if React component.<br>We can also compose bigger components<br>from smaller components.<br>In here, we actually can post the App component<br>using an h2 element.<br>If I have another component, I can use it inside the App<br>component, which is what we're going to do in a little bit.<br>But let me talk about this ESLint error that we get here.<br>First notice that these errors are not really errors,<br>the App is still rendering, but it's highly recommended<br>that you fix all these errors before you do anything.<br>So, this error says headerMessage is missing<br>in props validation.<br>This is our clue that any prop that we pass to a React<br>component has to be part of a prop validation.<br>We use prop validations in React to validate the type<br>of the values for these props, and this is done using<br>App.propTypes, which is just an object.<br>This is a React api, and inside this object we put the<br>actual props that we want to validate as keys,<br>and the type of these props as value.<br>This particular header message is a string.<br>We use another React api to do the prop validation.<br>The syntax is PropTypes.string.<br>When we save, the ESLint error is gone.<br>We can test, things are still the same,<br>but now I have prop validation.<br>This means if I don't pass a string, for example,<br>let's pass an number, and we try to render the app with<br>a header message that has the wrong type,<br>React is going to give us a very clear warning.<br>HeaderMessage is expected to be a string.<br>The other validation we should always do,<br>say that we do have a header message, but we tried to<br>render the component without a value for it,<br>React will actually just render without any errors,<br>and without any output here,<br>and this sometimes is a problem.<br>It would be great if React tells us that the App component<br>uses a header message and it was called<br>without a header message.<br>To accomplish this we can chain an isRequired calling here,<br>isRequired means this header message has to have value.<br>You cannot use the component without a header message.<br>Let's test, and now we have a clear warning that says<br>headerMessage was not specified.<br>One other feature we can use with components<br>is the default values for props.<br>The syntax is defaultProps, and in here it's also<br>another object, and the keys for the object are the<br>properties that we want to supply a default value for,<br>and the values are the default values, so let's do<br>Hello here, and since we have a default value,<br>we don't need to make this property required because we can<br>use the component without the header message property,<br>and we're going to use the default value<br>for the header message property.<br>Let's test.<br>So, make sure that you always use props validation,<br>and if you have any default values you can use<br>a default props feature.<br>"

## Component composability

"- [Instructor] Let's add some more content to our application. I'm going to put a div in here, and in that div, eventually we're going to render our naming contests; for now, I'm just going to do three dots. And you'll immediately get a JSX parsing error, that says these two HTML elements must be wrapped in an enclosing HTML tag. And the reason for this, if you remember, that this is a react.create element call, and this is another react.create element call. So we can't actually have them follow each other like this. Instead, to fix this problem, we're going to enclose both of them in a top-level div tag. So I'm going to put them in here, fix the indentation, and this should work, let's test that. So I got the header, and I got the content of the div. Now this app component has two parts. It has a header part and it has the content part. Because we have the React composability, we can actually take these parts into their own component. Let's call this component header. So, not only I'm extracting this header component to our reusability, but it's also now much more readable. The app components start with the header component. So let's define this header component. It's another constant, it's header, it's always a function, and it returns the header HTML, just like that. And I'm going to go ahead and give it a header message, which we can just call message now, because we are in header. Let's use the header of our app, Naming Contests, and in here instead of using props.message, we can actually destructure the property message here, and just use it directly in here. I'm going to remove the default value, but I'm going to keep the props validation, but we have to move it to the header, here, and instead of app, it's now header. Instead of header message, it's now message, still a string. I don't have any props here, so I'm just going to remove it for now. Looking good. Let's go ahead and test. There you go. So now this header component is a readable, reusable component that we used to compose the app component. And that made the app component shorter, and it also made the app component more readable. We know that this section here is a header. So a few more tips. I like to always give every top element a class name, just in case we want to style it later. And I like this class name to match the name of the component. Let's also make sure that you have the React extension tool, as you can see here, that I have it in here. If you don't have it, google for React devtools. You have a Chrome extension, and I think it's also supported on Firefox. This developer tool is really handy. First, it recognizes our structure, so you can see here we have an app component, and we have a header component. This is definitely much better than looking at just the raw HTML generated by the virtual DOM. But other than recognizing our components here, it also recognizing the properties, and when we start talking about the state, it also recognizes the state of our components. So it's a very handy tool to have in development, make sure that you get it and make sure that it's working for you. "

## Components with modules

"- [Teacher] You might have noticed that our index.js file is getting big. It simply has too much. It defines the Header component. It defines the App component, and it renders the app component to the dom. These are actually three separate things that needs to go into three separate files. It's a good practice to define a component per file. So I'm going to extract this Header component. I'll just cut it from here, and I'm going to introduce a new folder under source. Let's call this folder Components. And inside Components, we're going to have a file per component. So let's have a header.js. I usually match the name of the component to the name of the file. And in here, I'm going to paste the header.js code. So this header.js is going to be it's own module. For other modules to use the header module, we need to export it. So we do export default Header. Now since we're using React here and also we're actually using React here, remember, React.createelement, we need to import React. So let's import React from react. So I think this header component is ready. Now back in index.js, if we actually want to keep the App component here, we need to import the header component in here. So we simply go with import Header from ./, this is a relative path for the module, components/Header. And just by doing this, the index.js file is much shorter. So things would still work here. But let's take an extra step here and actually put the app component into it's own module as well. This would include the importHeader because the only thing that depend on the Header component is the App component so far. So I'm going to cut the code from here, create a new file, call this file App.js, paste the code, introduce the dependencies. We do have a dependency on React. This is actually in every component, and the header component now is on the same level, so we don't need to do ./components. We can just do ./Header. And don't forget to export the component so that other files can use it. So now back in index.js, the only dependency that we need is the App component, and we read that from ./components/App. Go ahead and test. And things still work the same. So now the index component has one responsibility. It renders a top level component to the dom. It's much shorter, and we also have a very clear dependency tree. We start with the index component. That component depend on the App component. The App component depends on React and on a Header component. The Header component only depends on React. So all these dependencies are a lot more clear now that we're using modules. Furthermore, there is some isolation of responsibilities here. So the App component doesn't really care about what the Header component does with that message. How the Header component is going to display that message, that's the business of the Header component itself. So we isolate these responsibilities when we start to introducing components like that. "

## Component state

"- [Teacher] The components we've been using so far are all stateless presentational components. We used the fuctions index to create these components. We call them stateless because we can't use the React state with these components. So if the component doesn't need state, this syntax is the way to go. Just a simple function. But let's assume that this component is going to need some state. In fact, let's put it in practical terms. Let's say that this header is going to be the main header when I go to the main page, but then when I go to any naming contests, we're going to change this header to be the title of the contest. Which means this header message is going to be dynamic, based on where in the app we are right now. So this is an example of something that should be on the state of the component. So let's put the header message on the state of the app component. Of course right now the app component is a stateless function component. So we need to convert it first into a class-based component. Sometimes you'll see examples React code that's using the create class syntax to create a stateful component, but we're not going to do that. We're going to go with the new syntax to extend react.component. Just like that. So what we do to make the app component extends reacting component, we're going to make this into a class. This class extends react component. I'm going to cut the return code here. Inside the class, we define the render function and this render function will return the markup that we had so far. So let's make sure this is working. And now the app component is using the other syntax which allows us to introduce state on the component. So only use this syntax if you need to introduce state or if you need the lifecycle methods of the component which we're going to talk about in the next movie. If you don't need either state or lifecycle methods, just use the stateless function component syntax. So we're now ready to introduce a state. You'll see examples that are using a constructor to introduce the state, just like that. Here's a state object. For example, we would have a property on this object, and then we can use it anywhere here inside a variable, in this case, we can do this.state.test, and that will read the 42 value that we have on the state. However, since we configured stage two, we can actually use a class property instead of having a constructor. Just like this, and this would be equivalent to what we did before. Test. So this is a much shorter syntax, and we're going to go ahead and use it. Now what I want to put on the state is the header message. So let's call this pageHeader, and this starts as Naming Contests, the current header. And now to read this here instead of passing in a string, we're going to pass this.state.pageHeader. Let's take a look. So now this string is coming from the component state, and we have control over it. In fact, take a look at the react devtools. If you go into the app component, you'll see that there is a state section here, and it has the page header property. So let me show you how we can control the state. Whenever we're hovering over a component, we can access it in the console using $R. So I'm going to go to the console, I'm going to take a look a $R. This is the app component. In fact, we can read the state of the app component directly from here. We can also change the state using the set state method. So what I'm going to do is I'm going to change the state, and I'm going to replace the value for page header to something else, and once I hit Enter, React is going to detect this change in the state, and it will rerender the dom for us. So this is exactly what we'll eventually do when we change into a naming contest page and we have to change the header. What I want you to understand is all we need to do to change the content in the dom is to change the state of our React component. And React is going to react when it sees the change in this state and it will take the change to the dom. "

## Component life cycle

"- [Narrator] Every React component has a life cycle. First it gets mounted in the DOM. Then the content of this component might get updated at some point. And then the component might actually be removed from the DOM. We can write custom code around these events in the life cycle of a component to customize the behavior. We use React life cycle methods to do that. There are a few life cycle methods that I'd like to talk about here. The most important one is componentDidMount. This is the life cycle method that guarantees that the DOM has been mounted in the browser successfully. Another component life cycle method is componentWillUnmount. This is the life cycle method that says the component is about to be unmounted. I'm going to put a console.log line here, and another one in will unmount. And after both of them I'm going to put a debugger statement. Don't worry about the ESLint warnings, these are just temporary. So now when we refresh you'll notice one thing. First we are in did Mount, and you'll notice that the component actually is mounted in the DOM because we can see the content of the component in the DOM. And then component will Unmount is not going to be invoked because we are not removing this component from the DOM. So I'm going to actually force removing this component from the DOM. It's simple. Let's start with a timer, setTimeout. This timer is a function, and let's invoke this timer after four seconds. And inside the timer we're going to force the DOM to render another element. For example, let's do another h2. And this call is going to actually remove the app component from the DOM because we're rendering something else into the same element. So let's test. We first get into the did Mount debugger call. And that works. And after four seconds the component is going to be unmounted. So in the console we'll see that we are in the will unmount phase now and the debugger stopped. The component is still in the DOM, but once I hit resume here, it's going to go away from the DOM. And you'll notice that we now have the new h2 content in the DOM. Let me clean that up. So this is what we do in componentWillMount and componentDidMount. If we have any custom behavior that we want to invoke around the life cycle of a component, we use these life cycle hooks. For example if you want to integrate your code with a third party plug in that depends on the fact that you have the DOM then you need to put your integration code inside componentDidMount. We usually also do any ajax fetching here in componentDidMount so that when it comes back from the server we are sure that we have DOM to modify with data. We also usually fire any timers in here or any listeners to other events, and in componentWillUnmount we usually clean those timers and listeners so that they don't leak out of the scope of a component. "

# 4. Working with Data

## Loading the test data

"- [Narrator] Let's make our React application work with some actual data now. I've prepared some test data for us to work with right here. You can find it under src, testData.json from the Github repo. I've tagged this point in the course as v4.1-begin. And this comment is going to give you the test data to work with. And this test data is simple. It has an array of contests. And every contest is an object that has id, categoryName and a contestName. And we're going to create a React application to properly display this information in the DOM. At first let's load the data directly in our React application. Since this is json data we need a way for webpack to understand it, and for that we need to install json-loader, which is a loader for webpack to understand json files. And to configure webpack with the json loader we add another loader entry here, just like the one that we have for js. This one ends in json and use the json loader on this type of file. And let's go ahead and restart webpack for this effect. And now in index.js I can just import data directly from ./testData. And I'll go ahead and test that we are reading the data directly from the json file. Refresh. And I have the data here in memory. Every object in this array has a categoryName, contestName, and an id. So now all I need to do is to pass this data to the app component. So I'm going to specify a property here, call this property contests. And I'll pass it as data.contests. "

## Displaying a list of objects

"- [Instructor] We now have access to the test data in our app component. In face, we can render the app component, let me remove the console log here, I don't need that anymore. Refresh the app component, take a look at the React Devtools, and when we are hovering over the app component, we'll see that we are receiving the contests array as a prop on the app component. So now in the app component we're going to go ahead and display the contest information. Let's start with one contest. Let's create a new component to represent a single contest. Let's call this component contest preview. I'm naming this preview because this is going to be the preview on the homepage and we're going to have another component to represent the full contest. This contest preview can be a stateless function component. We're going to call it contest preview, and we want to export default contest preview. And also don't forget to import react. This contest preview is going to receive a contest object. And we'll put the information for every contest object in here. Every contest object is going to have an ID, category name and contest name, so let's go ahead and display the category name first. This would be contest dot category name, just like we have it in here. And then in another dev let's put the contest name. So contest dot contest name. This component looks good, let's go ahead and use it. In the app component we're going to need to import this component. So import contest preview from dot slash contest preview. Then inside the render method we want to use the contest preview component and pass it a contest object, now we have an array of contests, so if we're testing, I'm going to pass the first element of that array. So this area is this dot props dot contests, this gives me the array of all contests. And I'm going to pass the first element of that contest. And we'll spread this object into the contest preview so that it gets all the properties for a contest on the first level, let's test. And there you go, the first contest is showing up. Now we're getting a prop validation here because contest is a property and we have not specified what is the type of this property, but I'm going to be removing this property soon. So let's just live with this error for now. So what we need is to take this component and actually use it inside a loop that loops over all the contests. In React this is easily done with a map call. So we start with this dot props dot contests, again, this is the array, and we're going to map this array into contest preview elements. So the map is going to expose a contest object for me, and inside the map I'm going to take the same call and instead of using this dot props dot contests zero, now I could just use contest. Let's go ahead and test. And as you can see, all the contests with all their categories are showing up now. Very simple, right. We start with the data array, and then we map it into a component per contest. "

## Using Sass with Node

"- [Instructor] To improve the display of our contests, off camera I added a little bit of CSS here to make it look a little bit better. I'm not a designer, and I don't claim to be, but this certainly looks a little bit better. Here's what I did, I gave the category name a class, and I gave the contest name a class, and I added this simple CSS here. Now, I have not persisted this CSS yet, so let's go ahead and do that. Let me create a new file and paste the CSS in here, and what I want to do is, I want to use Sass, because I think it has a lot more power that the CSS. For example, in our simple CSS, this is actually nested instead of doing .ContestPreview every time, I can go ahead and nest this calling here, which allow me to get rid of this duplication here, but this is not valid CSS, this is Sass, so the browser is not going to understand it. So, I'm going to take this Sass code, and save it as a Sass file. Let's introduce a new directory here, call this directory Sass. Now we'll put any Sass styles inside this directory. So, I'll save this new file as style.scss. The extension is scss which stands for Sass CSS. Now, I have two options, we either make webpack translate this Sass for us into CSS, and use the CSS directly in our application, or we can have node translate this Sass into Css directly, and this way is a little bit better because we get to use it directly on server load. So, there's a node-sass-middleware that we can use to make this work in node. All we need to do is npm install it. Node-sass-middleware, and once we have it, we can go into server.js to use it. We need to import it, call it sassMiddleware. We import it from node-sass-middleware, and we'll also import path from path, this is a built in node module, and to use the sassMiddleware with express, we do server.use, the sassMiddleware that we just defined, which is a function, and this function takes an object, and in here we specified configuration that we want to work with this middleware. Most importantly, we need a source directory to read the sass files from, and a destination directory to write the generated CSS. So we'll use the path library to work with these directories, so we want path.join starting from the current directory, and joining the sass folder, and similar to this the destination is path.join directory into, let's just put in the public directory. Restart the server, and if all works, this middleware is going to give me a style.css file in the public directory. So, all I need to do is go to my header.ejs, and include this newest style, which is another link, stylesheet from the public which we can read directly. So, it's just style.css. Refresh, and it's working. So, with this configuration, we have the power of Sass in our project. I'm going to make sure that things are actually working, I'm going to make this border ugly green. Refresh, and it's working. So, what happens here, every time I change this file, nodemon is going to restart my node server, and the sass middleware is going to pick this file, translate it into CSS, and allow me to use it directly from /style.css. So, to get all the code that I did in this movie, I tagged this point in the course as v4.3-end, in here you'll get the configuration of the sass middleware, and you get the CSS that I have. "

## Reading from the state

"- [Instructor] You might have noticed that we're actually getting a warning from React in our current code. This is because of our dynamic array mapping here. Every time you display a list of things dynamically, React needs a little bit of help. It needs you to identify every element with a key. This key helps React identify the element when this array of children changes. So we can simply use the id for every contest in this key. contest.id. And let's go ahead and test. Now that warning is gone. So just remember, every time you have a map call, you need to provide a unique key to identify the child element inside that map. One bit of advice here. Do not use the array index as a unique key. Try and find another unique key to identify an element in an array. In our case, our data had an ID. And usually an API data is going to give you an ID for every object, so just use that. Now we have a React component that renders an array of contests. And we have the data, which we're reading into memory directly before rendering the React application. However, practically, this data is going to be sent from an API and this process is going to take a little bit of time. React application is going to render before we have the data. So assuming we don't have the data yet, what are we going to do? We'll have to render the React application with an empty array, just like that. Let's actually test. So no errors. React is actually rendering an empty list of contests. And now assuming after a while, when we get the data back from the API, we'll have to render it inside this React component. So to do so, we need to update something in the component. Now remember, the only thing we can update inside the component is the state of that component. Instead of rendering the contests from props, we're going to render it from the state. I'm going to remove it from here. Go to the App component. And put the contests on the state of this App component and read the contests directly from the state, instead of the props. So this should be exactly the same, no errors, and the App is rendering an empty list of contests. And in here, I'm going to actually import the data directly from testData one more time. This is now of one level. Although I'm reading the data directly from memory, I'm going to assume this process happened after React rendered all of the components to simulate an API call. So since we're already mounted, a proper place to do any modification now is inside component didMount. Inside component didMount, when the data is accessible, I'm going to go ahead and do this.setState and contests is coming from data.contests. Just like that. After React gets mounted, we can control when this happens exactly. And when we have access to the data, we just use setState to put the data back inside the React state. Let's test. Now the App component is reading this list from the state. And we have a plan to work with any delay in fetching the data from an API. Also having this data on the state, allows us to control the list. For example, let's go to the React dev tools. Hover over the App component to get $r. And in here, I'm going to do $r.setState. And in here we're going to do contests is $r.state.contests. Just a current list. .slice1. So when you do slice1, you're basically deleting the first element in the array. Once I hit enter, this first element in the array is going to go away. Because this contests is part of the state, React is going to do this automatically. Let's test. There you go. "

## Fetching data from a remote API

"- [Instructor] So now that we have the data on the state, we can start working with the data API, instead of reading the data directly from memory. So we're kill this line, and we're going to go prepare and API endpoint on the back end instead. So if you remember, in server.js, we prepared an API endpoint at /api, and started preparing an API router module under API. Right now, we're returning an empty data array. So what we want to do here now is to have an API endpoint to serve the contest's data. So we'll have this API endpoint under /contests, so that we can get to it with /api/contests. Instead of sending data, we're just going to send contests. And in here, we're just going to read it from the same file directly, so I'm going to import data from test data, which is up one level from here, under source /testData. And now the contests can be read with data.contests, so let's go ahead and test that. We go to /api/contests. And we get a list of contests here in an API. Cool, so now we need to use this list of contests from the React application. Right now, the React application has an error because we don't have data. And we're trying to use the data directly in here. So what we want, is we want to do an Ajax request here, and fetch the data from the remote API, and once we have the data, we make it available through the React state. So we need a library to do the Ajax request for us. One of the popular libraries to do so is this axios library, so we're going to use it. The syntax is really simple, after you install axios with npm, this is how you do it. So let's go ahead and first install axios, and we're going to import it here, in the React application. And inside component did mount, we're going to start with an axios.get call, and specify the URL for the API endpoint that we're going to read. Since we're on the same server for now, it's going to be /api/contests. Axios is a promise-based, so this would give me a promise, and for every promise, we handle it with a .then method, and we also need to catch any error that happens in the promise. For catching the error, let's just console error it out. Inside the then method, axios is going to give us a response object. This response object will have the data, so let's actually console.log response to make sure that we are receiving the data properly. And I'll common out this part of the code for now, and let's test. So it looks like I'm getting an object, this is the response object, it has some method like status okay, and my data is inside the response object here. So my contests' data is response .data.contests, according to the object that I'm receiving back. So what I need to do in this case, I need to take this exact statement that we used before to set the data directly from memory, and actually set the data directly from the response object that I'm getting back from axios. So set the state, the contests is going to be response .data.contests. And let's go ahead and test. Refresh. And, the data is now being loaded through an Ajax request, and getting set on the React component state. "



# 5. Rendering on the Server

## Fetching data from the server side

"- [Instructor] Our React application is rendering data from the server using JavaScript. But what happens if we don't have JavaScript? We can actually disable JavaScript completely, here. Let's try. If we refresh, our application is empty. In fact, the only thing that it renders is the original content that we rendered to our ejs template. This is exactly what most search engines see if they request the application. We'll simulate that with a curl, localhost, port 8080, and the only content that they see is that. Ideally, we want this command to also render our application as seen by React so that we get the benefits of search engine optimization, and also we get a little bit of performance benefit. Instead of waiting for React to warm up, render the component, and then go back to the server to fetch the data, we can have an initial view ready by the server. So, to do that, we're going to have to modify this code, here, to pre-render all the React components on the server using the same data that we have in the API. However, remember that we're doing all the different parts of this project in a single Node application, but we're going to consider them separate. So, I'm going to consider the React application is separate from the API application. So, I need this server code to be able to read data from the API part. Let's create a new file. Call this file serverRender.js. And in this file we're going to fetch the data from the API assuming that this part does not have direct access to the data, and it needs to go to the API server to fetch the data. So, we're going to actually import axios from axios, just like we did for the front end. And we'll try to do axios.get a URL here, and then do something with it just like we did in the front end. However, I can't do /api here, because this is not a front end trigger. I have to actually do the full server. But instead of hard-coding any server host here, we should really read it from the configuration. So, I'm going to go back to the config.js file. We've configured the port, here. Let's go ahead and also configure the host. This would be env.HOST for us to be able to control it from the environment. And the default is, let's map it on 0.0.0.0. This way, it will bind to all the IPs on the machine, so we can actually test it from other machines. And let's also define a server URL. I'm going to make that into a getter, serverUrl. So, this would return a string ready for us to use. This will be an http, and in here we're going to do this.host and then this.port. So, this way it's ready for me consume directly as a property. So, in serverRender we'll need to import the configuration. So, let's import config from ./config. This is a local file. And in here our URL is ${config.serverUrl} and then /api/contests. And I want to make sure that this is working before we proceed, so response is, let's just console.log resp.data and see that working. I'm going to go ahead and import/serverRender just to trigger the code that I just did. And, actually, in the listen part, here, when we listened to the port, we should also listen to the same host that we configured in our configuration. So, config.host. This way it will bind to the same hose that we have. So, let me see all this working. It looks like it is working. The npm restart here. I am seeing the data from the console.log statement. So, that's a good first step. In the next movie, we'll take this data, and we'll pre-render our React components using this data and make it available directly with HTML. "

## Server rendering with ReactDOMServer

"- [Instructor] To render React components on the server, we're going to use the ReactDOMServer package. To be able to use this ReactDOMServer, we're going to have to import React itself first and we'll also need to import ReactDOMServer from react-dom/server. And we also need our own React application. So we're going to import App from ./src/components/App .js. This is the top level of our React application. And then in here, we can use ReactDOMServer.renderToString and give it our own component. Just like that. This would read the React code and renders everything to string. Let's go back and take a look at our React component. And you'll remember that our React component depends on the state to load the data. So there is no way for me to pass the data in here to the React component to prerender the component with data. That's not going to work. The code of this component right now is not very friendly for server render. And what we need to do is we want to make this component able to render the contests using initial data here. Let's go with initialContests. And by default, we can pass this as an empty array here and then in the App component instead of hard coding this, we can start this using this.props.initialContests. This way the React application on the front end will continue to work exactly as it was- an empty array and then it loads to the state. However, if another code that's rendering the same component actually specifies in initialContests values, then the application will render with initial data. So the initialContests here is something that we want to read from the response. So it's response.data.contests. Just like that. And we'll put that in multiple lines. So ReactDOMServer, renderToString, the App component initialized with actual data. Cool. So this is the exact string that I want to feed to the EJS template. However, this string is inside a promise. This whole call returns a promise. So I cannot use it directly. What we can do is, let's return this value from the bin and let's wrap all this call in a function and call this function serverRender. This is a function that basically returns a promise. Just like that. And we're going to go ahead and export default this function serverRender. So now back in server.js, instead of importing this directly, we're going to import serverRender from serverRender. And serverRender would be a function, so we can call it as a function. serverRender is a function. And this function returns a promise. I can do .then on this promise. Just like I did before. And I also need to do .catch just in case something is wrong with the promise. And in here we can just do console.error. And what I want to do inside the then, this promise actually gives me the content that I want to feed to the EJS template. What I'm going to do is I'm going to take this call here and I'm going to put it inside then, and when I do have the content go ahead and render it. Just like that. I think we can test. There is an error because I cannot spell components. Let's test. Looks like the server is listening. And we can redo this command to test. And look at that. I can see the data now. It's coming directly from the ReactDOMServer. Basically, we can render our application now with JavaScript disabled. And it's actually rendering html. And here's the cool thing. You can enable JavaScript, render our application, the initial data is going to come from html and then React is going to take over and re-render the content for us. However, there is a problem. And it's clearly communicated here. The problem is... Let me actually simulate this problem for you in the App components. Right before we render, I'm going to put a debugger line. Here's the problem. When I receive a response from the server, that response has an actual DOM. Even before I render anything from the React component itself. However, when I hit play, React is going to render an empty list of name contests because, by default, it's taking the initial contests from index.js, which has an empty list of contests. We're going from a full list of contests into an empty list of contests when I hit play and after that, React is going to go back to the server, fetch the list of contests again, and put it back in the DOM. This is why we're getting this error. As you can see in this second render call, after we fetch the data React actually wiped the naming contests clean. So now we have an empty list of contests rendered in the page and we went back to the server to read the data and now we're going to re-render the data. React is not really fully benefiting from the server rendering that we did. In the next movie, we're going to fix this problem. "



## Fix the checksum problem

"- [Instructor] We got the server to render, however, it's not playing very well with the front end react application because the react application is still initializing the DOM with an empty list of contests and then going back to the API to fetch the actual list of contests. So I'm going to show you two solutions for this problem. First on the front end we can't actually initialize this code with an empty array. We have to initialize this code with the same data that we did on the server for the back end and front end to sync together without any problem. And we can't also reset the state here because that would be wasteful. If we have the data to begin with then we don't need to reset the state. So I'm going to actually remove this code in here and let's go back to the index.js. Since we need to bring the data before actually rendering the front end component, I'll go ahead and make an Axios call here. Instead of setting the state I'll do the react-dom render call itself in here. And the initial contests here are response.data.contests. So we don't need to set the state here and we need Axios, we don't need it in app at all, so I'm going to remove it from app and put it in index. So let's actually test. Refresh and you'll notice that this sync error is gone. And the reason it's gone because the markup that we are rendering from the server now matches exactly the markup that react is starting with. React does not start with an empty list, it does not use set state to regenerate the list, but it's still doing one wasteful API call to /api/contests. It's not really necessary to go back to the server because we already have this data. However, this is one solution to the problem that is not too bad if you're okay with a client going back to the data api. I'll show you another solution that does not require us to go back to the api to fetch the data for the react component. And that solution is to also return the data itself from the server. So in server render, when we returned the DOM itself here, I'm going to go ahead and return two things. I'm going to return the initial markup that we need, and this would be the exact thing we returned before and let's also return the initial data because we have it already. And this would be response.data and only to modify server.js to also include both of them in ejs. So this would give me an object with two properties, the initial markup and the initial data and I want to include them both in ejs, so initial markup and initial data. And now in the index.js where I'm rendering the content, this is now called initial markup, I'll also include a script tag and put the initial data as a global variable on the window. Window.initialData equal the initial data that I'm reading from the ejs variable. So that would be initial data. However I can't really read it directly like that. I'll have to stringify it so we can simply do json.stringify here and now when I refresh the server not only do I get the markup I also get a global variable that holds all the data. So in my front end component that renders instead of doing an extra hit to the API we can just render directly using window.data.contests. And I don't need Axios at all. Let me make sure everything is running correctly. Doesn't look like it's working here. Let's review. Server render returns both initial markup and the initial data, perfect. It returns an object and in the server digest, initial markup initial data we actually need to destructure those. Let's test and take a look at this. It looks like we have the markup back in here. So let me test it on the web. Definitely not working. View page source, actually it looks like it's working, I see initial data. So basically what we need is window.initialData.contests. What did we actually use? We used data. This is initial data. Okay let me test. Take a look at that. React is now re rendering this view in sync with the server rendered view and it's not giving me any errors. So here's what is happening. If I don't have java script the application is still working. It gives me an initial rendered markup using react-dom server but if I do have java script not only do I get the markup but I also get the data as a variable on the window. Window.initialData. So I don't have to go back to the server to retrieve that data for the React application. So now the React application can re render itself using the same data that we have on the server and actually this whole operation on the front end is going to be a no operation because React will find out that the same content is already rendered to the DOM so it will not go back to the DOM and re render it. So we get both the benefits of exposing our content to be visible for search engines and also we get a little bit of performance improvement in the react front end code because the browser already has a copy of the DOM that matches exactly what react will try to put back in the DOM and the virtual dom will just do nothing. So this is another solution but you do have to pick your weapons here. Because I imagine that some people would think that this is actually a hack. But it did save us an extra round trip from the client to the server. "

# 6. Routing on Client and Server

## Handling the contest click event

"- [Instructor] The next thing we want to do is click on every contest to navigate to that contest and start giving the users more features on that contest. So let's start by implementing a simple click function here and console logging the contest that we just clicked. So let me take a look at what we have. The app component here renders header, and then it loops over the contests to render a contest preview. I think we should actually refactor this code into it's own component before modifying the contest preview. So I'm going to take this part and then under components, we're going to create a new file, call this file ContestList and this ContestList can actually be a stateless function component. So call it ContestList. And this would simply just return the same mark up that we have in the F component, we don't need this extra div. And it will receive as probed, the list of contests, call them contests. And it will render them directly here, we don't have a state. We need to import React, and we need to export default ContestList. And let's define the props that we have here. So ContestList.propTypes equal, the only prop we have is the contests object, which is an array. So React.PropTypes.array. And we need ConstestPreview, so we're going to actually remove it form App.js because we're not using it here anymore. And put it in ContestList. So this ContestList looks good. Inside App.js, we want to import this new component which is ContestList, and we'll just use it in here. ContestList, passing in the contests, which we can read from the state. This.state.contests, just like that. So I think this is looking good, test to make sure that it's still working. And now inside ContestPreview, what we need is we need to define an onClick handler here. And this onClick handler is going to be a function. Now if this was a static function that doesn't depend on the actual object inside every ContestPreview, then we can potentially pass it down from the parent as a property, and just use it here as a reference. But this particular function needs access to every contest object, because we're console logging the contest data, or we're eventually going to access the contest data when we click on here. So this is a dynamic function that depends on the content of the ContestPreview function, and since this is a stateless function component, we can't actually have a dynamic function. If we do a dynamic function here, it would mean that every time we render this contest preview it's going to create a new function, and that's not very good. So if we have a stateless function component like this, and we need to handle events dynamically, we should upgrade this component into a class component So we're going to do a React class component, and it's the same name, ContestPreview. And it's also the same mark up, and instead of contests, we don't have an argument like that anymore. We're going to use this.props dot the property name. Now we don't need this anymore, and we're going to go ahead and define the props for this component, so ContestPreview.propTypes, equal, we have a category name, which is React.PropTypes.string. This is required. And we also have a contestName. Okay, so now that we have an instance, we can use an instance function in here. Let's call this function this.handleClick. And let's go ahead and define this function, handleClick is a function, use the property syntax here so we can access this inside. Let's log this.props.contestName. Component is undefined, we can de-structure it from here. And I think we can test. Refresh, clicking on every contest will give me the name of that contest. Although when I hover over these, they don't appear clickable, because the cursor is not a pointer. So let's fix this, this is very simple. I'm going to give the top level class here a link class, and inside my style sheet I'll do a link top level class here with cursor pointer. That should fix it. Refresh, clickable. And we can click it. "

## Navigating to a contest

"- [Teacher] Let's use the native browser's history to navigate to a contest. I'll be using the HTML5 history API here. This is decently supported on most modern browsers, but if you do need to support other browsers, you can use a library that does a fall-back to older browsers syntax when it doesn't detect the history API. I am also going to do a very simple routing without a library. I'm going to do this so that you get to understand the mechanics behind the routing and how it relates to server-side routing and server rendering in general. And the other reason, we only have one route in our application. We actually have two. We're going to go to a contest, and we can go back to a list of contests. So it's going to be simple enough for us to just use the history API directly. If you have complicated routing, the react router library is really good and it gives you a declarative way of defining your routes, but we're going to just use the history API. However, I'm going to put the history API in a function here. Let's call this function pushstate, and this function will receive the same parameters that the official pushstate receives. So I'll go with object, and we'll go with the URL and this pushstate is going to be an alias to window.history.pushstate, the object and an empty title and the URL. This way if I decided later on to support older browsers, all I need to modify is this function. So as a first step, when we click on a contest right now, we are recognizing the contest that we just clicked. Let's make the history API go to /contest/ the ID of that contest. So we'll declare a function here. Let's call this function fetchcontest. This function will eventually fetch the contest information from the server when we click on it, but for now, it only receives the contest ID. This is a function, and it will use pushstate to push a history record. First argument is the object about that record, and the second argument is the URL. So the URL is going to be /contest/ the contest ID that we are receiving, and let's put on the state object, let's put the current contest ID. Make that the contest ID that we're receiving. And now we want to use this fetch contest when we click on every contest, but we define this here on the main app component because it will eventually modify the state. So I'm going to pass it down to the children component. Let's call this onContestClick. This would be this.fetchContest. And then inside contest list, we're going to receive a new property, this property called onContestClick. This is a react.PropTypes.function, and it's required. We'll have to also pass it to the contest preview. Let's call this onClick. This would be the onContestClick property that I get passed, so I need to destructure it here. Inside contest Preview, we're going to also receive an onClick property. This is a react.propTypes.function, also required. And inside handleClick, I need to call this property. So this.props.onClick, and I want to send as an argument, this.props.id, however this is the first time I'm using the ID so I have to define it here. PropTypes.number.isRequired. And I think we're ready to test. Refresh. When I click on this one, the URL changed to Contest/2. Let's try clicking on this one. Contest/4. And I can actually go back in history and go forward in history and the URL is working, however, I'm not changing the content yet. I'm just changing the URL. So in the next movie, we'll change the content when we click on a contest. "

## Looking up the contest on route change

"- [Instructor] Let's now look up the contest when we click on it. Right now, the route changes, but the content doesn't. So we're going to start changing the content here. In particular, when I click on a contest, after I change the route, I want to look up the contest. I want to be able to put things on the state that are related to that contest that I just clicked. However, the contest structure is an array. So right now, api/contest is giving me an array. And if I want to look up an item using the ID of that item, I have to scan the array; that's not very efficient. What we can do before doing anything related to contest lookup, is to change the structure from an array into an object. Once I have it as an object, my lookup will be a constant time operation. So this is what I'm going to do first. I'm going to go to the api module and in here, when I return the data as an array, let's convert it into an object. There are many ways to do so, the easiest way is just to reduce array into an object. Reduce give me a function in the first argument, and we'll start with an empty object. The function is going to expose the object that we're going to return and in every iteration we have a contest object. Assign it as a property on this object with the key being the contest id. And the value is the contest itself. And we need to return the object here. So this very simply made the array into an object with the id's being the contest id's, and the values being the actual contest objects. Let's actually test. As you can see, we have every contest now is a key value pair on this contests object. Of course, instead of doing this conversion here on the request itself, we can extract it into a variable. So we put this variable on server load, let's call it contests. And we use the same conversion, so in here contests is going to be already object and for every request, I could just use that object. So we do this operation once and then we reuse it. So that's much better. But this is all not very super important because we are going to change our end memory data structure to work with MongoDB very soon. Of course we need to change our application to now read from an object instead of an array. In here, the contests get passed to the contest list, so I don't think we need to do any changes here. In the contest list, the contests variable is now an object, not an array, and we're doing a map operation on it. So this has to change, and what we can do is we can iterate over the keys of that object. So object.keys for contests and this would expose a contest id now. And inside here, we can use the id directly. And for the contest itself, we have to look it up from the id that gets exposed on this loop. So contests for this contest id. And also contests here is now an object, not an array anymore. So let's test. Going back here, refresh, and it looks like things are working because we have contest object here and the application is rendering. I would also test it offline, should always do that. It looks like it's working offline as well, very cool. So now that I have an object as my data structure, I can very simply look it up here with a constant time operation. So the actual contest that we're navigating to is going to be this.state.contests, looking up the current contest id that we're navigating to. So what I want to do, I want to change this state, setState. Let's start with a pageHeader. So the pageHeader, when we navigate to a contest, is going to be the current contestId.contest Name. And I think we can actually test that. So clicking on this contest, there you go. So now that we changed the title, let's go ahead and try to change the content as well. To change the content, I have to do a condition statement here and say something like, \"do we have an active contest? Do we have a current contest?\" So to do so, I'm going to also place the current contest id on the state as well. So now when I click on a contest, not only I get the header here, I also get the current contest id. Which means, I can replace this with a conditional now and say, \"if there is a current contest id on the state, then go ahead and display contest information. Otherwise, display the contest list information.\" So to do so, I'm going to take this code here and place it in an instance function. So this dot, let's call this, currentContent. So this is a function that I'm invoking directly. So I'll define it here, currentContent. This can be a direct method here. And it will have an if statement and return either a contest component or the contest list component that we just removed from the render method. So let's figure out this condition. This condition would be, do we have a current contest id on the state? If we do, then we need to return a contest component. Otherwise, we just return a contest list. Of course a contest component is going to need the contest object to display, so let's spread a contest object here on this new contest component. This contest object would be this.state.contests for this.state.currentContestID. And we want to spread this guy in here. just like that. So let's actually create this new contest component. This component will be a new file; we'll call it Contest.js. And this component will do a lot of things, it will handle events, so I think it's safer to go with a class syntax. So we have Contest and we need to import React. I'm going to go ahead and destructure both Component and PropTypes, and we need to export default Contest. And for now, let's just put a placeholder here and just display the contest id. So this.props.id, the id would be Contest.propTypes. We're using the id, which is PropTypes.number.isRequired. PropTypes is a value here, and I think we can actually test. Let me fix this small syntax problem here. And we need to import contest. And this is looking good, let's try and test. So when we click on this Free programming books contest, not only do I get the URL change, but I also get the id of the contest in this new contest component. "

## Fetching contest information from the API

"- [Instructor] Let's now fetch one contest information from an API when we click on it. 'Cause right now, we don't go to the server. When we click on a contest, we need to go to the server and ask the server about more information about that contest. For example, its description and eventually any names that we proposed already on this contest. So let's start with an API. We need to go to /contest/ the id of the contest to look up a contest by id; right now we don't have that. So this is simple. Under API index, let's introduce a new route. This route will be /contests/:contestID. This is how we do it with express. And once we actually do the request here, the id that we put in the URL is going to be available as req.params.contestId. So really what I want to do is I want to look up a contest here, contest equal. I'm going to look it up from contest, which is my object, using this req.params.contestId and this would give me the contest object. Now I don't have any extra information about the contest because we're still working with fake data. But let's go ahead and introduce a description field. And also fake it with a place-holder. So this way, we know that we're actually hitting an API that giving me an extra description field. And I'm just going to render the contest itself here in the API, so let's test that. So we have the big data analytics and a place-holder description. On four, we have 'Free programming books' and the place-holder description. So this is good to go. Once we switch to actual data from Mongo, we just need to change the logic inside these API endpoints. So now in our application, we need a place to fetch this information with ajax. So let me introduce a new file undersource, call this file api.js. This is where we should place all our API logic. So this is the only file that should import the library to fetch from ajax, and in here we'll export multiple functions to fetch different things from the API. So our first function would be to fetch a single contest. And this function is going to receive a contestId and it will return a promise from axios to get this API/contest/ the id of the contest that we're interested in, contestId. And let's also just return the data from the response, so it's resp.data, so we'll go ahead and just export this. Cool, so now in the app.js, right before I set the state to the currentContest, how about we fetch the contest first. So let me import everything from the API, which is ../API, and then in here, before I set the state, I'll do an API.fetchContest. Give that the contestId that I'm trying to fetch. Then when I have data from this API method, it's going to be the actual contest coming from the server. So I'll just do the same set state call inside in here now. However, instead of looking this up from the state, I could just simply do contest.contestName and its current contestId is going to be contest.id. So I'm making sure that we're using the valid information coming from the server. And just doing the current contestId is going to switch to this view. And this view is just looking up a contest from the state. So what I can do to make this view read the description and everything else in the contest, is I can modify the contests object that I have on the state by copying the current contest object. So it's state.contests. However, the property associated with the current contestId, so contest.id is a dynamic here, I can set that to the new contest object coming from the server, and that's the one that has the description and everything else. So this way, I cache the fetched contest information on the state, and when I start going back and forth, this is going to be an improvement on performance. Because if I already have a description for a contest, it will be on the state. So I think this is good to go. Except we need a semi colon here. Thank you, yes lint. And now, inside contest, we can start using more information coming from the API. So I'm going to go ahead and use the description here. And I have a description, which is a string, not using the id anymore. And I think we're ready to test. Let's check it out. Free programming books, there you go, it's reading the API. In fact, let's make sure this is happening. Back, refresh, in here in the network, we can see what's going on. So when I click contest, I'm expecting the network tab to show that I am going to fetch one contest from the API. And that's exactly what happened. And you can take a look at what's going on here, it's returning a single contest with a description. "

## A bit of refactoring

"- [Instructor] Let's do some refactoring. First, let me extract this long line here that fetches a current contest into its own method. I'm going to call this method this.currentContest. We need to invoke it, so currentContest is a method that just returns this line, making sure things still work. Perfect. We always refactor in the green state when things are working and we're not getting any errors. So what I want you to think about now is this pageHeader, which we start with a static value and then, once we click on a contest, it actually gets its own value from the contest name. But this pageHeader can't actually be computed. We don't need to put it on the state. If we have a contestId, we're going to read the current contest name. If we don't have a current contestId, we just go with the default naming contest. So I'm going to actually remove it from the state and instead, let's create a pageHeader function. So this is very simple. If I have a current contestId on the state, then the pageHeader is going to be this.currentContest, the function that we just created, dot contestName. If I don't have a current contestId, then I'm just going to return the default, which is Naming Contests. And now everywhere we have a pageHeader, instead of reading it from the state, we can read it from this new function. And we don't actually need to set it on the state here. It's computed. So remove. Looks good. So let's actually test this. So refresh, pageHeader is getting the default value. And when I click, it's getting computed. So this is one item less from the state, which is always a good thing. Only put on the state the things that you can't compute from other things. And if there's something you can compute, instead of putting it on the state, just compute it. The other thing I want to refactor is in the server render. So in the server render file, we're returning the initial contests to the app. But once we start refreshing this page here, which currently does not work, but when we want it to work, then this is not going to be a valid way of passing the data. Because the initial structure of the data is going to be different when I refresh the main page versus when I refresh a contest page. So what I want to do here, instead of passing the initial contests, I'm going to pass the initial data itself. And in here, I'll just pass resp.data. So this way, I can actually control the initial structure that I passed to the app component, and it can account for either a list of contests or a current contest. So to make that happen, we need to change our app. 'Cause right now our app assumes that we get initial contests. So we're going to go ahead and give it the initial data itself. And this is coming from the initial data. And inside the app component, I don't have initial contests anymore. What I have is the initial data, which is actually top level, so the whole state is going to be initiated as this.props.initialData. And let's go ahead and define the type for this initial data, so we can do static propTypes here 'cause we have a class syntax here, so the propTypes can just be a static property in here. And my initial data is React.PropTypes.object.isRequired. And let's make sure this is working. So refresh, looks like it's working. One more time, perfect. So now I am ready to refresh this URL and server render a single contest page, which we're going to do in the next movie. "

## Server-side routing for a contest

## Navigating to a list of contests

## Handling the browser's back button

# 7. Working with MongoDB

## Reading data from MongoDB

## API to fetch a list of names

## Displaying the list of names

## Example script to update all data

## Converting the application to use _id

## Creating an API to propose a name

## Wiring the proposed new name form

# Challenges and QA

# Alternatives: MERN and Electrode